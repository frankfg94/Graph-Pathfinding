/*package L3_C5_thgraphes_pathfinding;


import java.util.Arrays;
import java.util.ArrayList;



public class L3_C5_Bellman 
{
    // k_line correspond à une ligne d'étape. On réduit ici le nom de son type.
    private class k_line extends ArrayList<ArrayList<Integer>> {}

    /**
     * Initialise un k_line
     * @param c nombre d'élément
     * @return un nouveau k_line
     */
    private k_line new_kline(int c)
    {
        k_line nkline = new k_line();
        for(int i = 0; i < c; i++)
        {
            ArrayList<Integer> tmp = new ArrayList<>();
            tmp.add(0);
            tmp.add(-1);
            nkline.add(tmp);
        }
        return nkline;
    }
    
    //le graphe
    L3_C5_Graph g = null;  
    //l'ID du sommer de départ
    int start = 0;
    int vcount = 0;
    //Double ArrayList (tableau de bellman)
    ArrayList<k_line> bellman_array = new ArrayList<>();
    
    /**
     * Constructeur
     * @param g, le graph
     * @param start, l'ID du sommet de départ
     */
    public L3_C5_Bellman(L3_C5_Graph g, int start)
    {
        this.g = g;
        this.start = start;
        this.vcount = g.getVertexCount();
    }

    /**
     * Execute l'algorithme de Bellman
     */
    public void process()
    {
        k_line a = null;
        k_line b = new_kline(vcount);
        
        
        b.set(0, new ArrayList<>(Arrays.asList(0,start)));
        

        do
        {
            print_k_line(a);
            bellman_array.add(b);
            a = b;
            b = new_kline(vcount);
            // je parcours a et b de 0 à vcount -1;
            for(int i = 0; i < vcount; i++)
            {
                b.set(i,get_new_iter(a,i));
            }
        }while(!k_equal(a,b));
    }
    
    private ArrayList<Integer> get_new_iter(k_line km1, int v)
    {
        k_line stock = new k_line();
        for(int i = 0; i < vcount; i++)
        {
            if(!(km1.get(i).get(1).equals(-1)))
            {
                for(int j = 1; j < km1.get(i).size(); j++)
                {
                    ArrayList<Integer> res = arc_to_list(km1.get(i).get(j),v,km1.get(i).get(0));
                    if(res != null)
                    {
                        stock.add(res);
                    }
                }
            }
        }
        
        if(stock.isEmpty())
        {
            return new ArrayList<>(Arrays.asList(0,-1));
        }
        int min = stock.get(0).get(0);
        for(int i = 1; i < stock.size(); i++)
        {
            int t = stock.get(i).get(0);
            if(min > t)
            {
                min = t;
            }
        }
        ArrayList<Integer> return_value = new ArrayList<>();
        return_value.add(min);
        for(int i = 0; i < stock.size(); i++)
        {
            if(stock.get(i).get(0) == min)
            {
                for(int j = 1; j < stock.get(i).size(); j++)
                {
                    return_value.add(stock.get(i).get(j));
                }
            }
        }
        return sort_arr_list(return_value);
        
    }
    

    ArrayList<Integer> arc_to_list(int src, int dest, int sum)
    {
        if(src == dest)
        {
            return new ArrayList<>(Arrays.asList(0,src));
        }
        L3_C5_Vertex v = L3_C5_Vertex.FindVertexWithID(dest,g);
        L3_C5_Arc a = v.getArcComingFrom(src);
        if(a == null)
        {
            return null;
        }
        
        sum += a.value;
        ArrayList<Integer> new_array = new ArrayList<>();
        new_array.add(sum);
        new_array.add(src);
        return new_array;
    }
    
    
    /**
     * Afficher les résulstats de l'algorithme
     */
    public void print()
    {
        
    }
    
    /**
     * Compare deux k_equal (permet de vérifier si on a fini ou non les ittérations)
     * @param a element 1
     * @param b element 2
     * @return faux si différent
     */
    private boolean k_equal(k_line a, k_line b)
    {
        if(a == null || b == null)
            return false;
        // les deux k_lines ont FORCEMENT la meme taille
        assert a.size() == b.size();
        for(int i = 0; i < a.size(); i++)
        {
            if(a.get(i).size() != b.get(i).size())
            {
                return false;
            }
            for(int j = 0; j < a.get(i).size();j++)
            {
                if(!(a.get(i).get(j).equals(b.get(i).get(j))))
                {
                    return false;
                }
            }
        }
        return true;
    }
   
    
    private ArrayList<Integer>  sort_arr_list(ArrayList<Integer> a)
    {
        ArrayList<Integer> new_arr = new ArrayList<>();
        new_arr.add(a.get(0));
        for(int i = 1; i < a.size(); i++)
        {
           int j =1;
           int val = a.get(i);
           while(j < new_arr.size() && val < new_arr.get(j))
           {
               j++;
           }
           if(j >= new_arr.size())
           {
               new_arr.add(val);
           }
           else if(!a.get(i).equals(new_arr.get(j)))
           {
               new_arr.add(i,val);
           }
        }
        return new_arr;
    }
    
    private void print_k_line(k_line l)
    {
        if(l == null)
        {
            System.out.println("NULL");
        }
        else
        {
            System.out.println("------------------");
            for(int i = 0; i < l.size(); i++)
            {
                for(int j = 0; j < l.get(i).size(); j++)
                {
                    System.out.print(l.get(i).get(j)+" ");
                }
                System.out.println(" ");
            }

        }
        System.out.println("Press Enter key to continue...");
        try
        {
            System.in.read();
        }  
        catch(Exception e)
        {}  
    }
    
}

*/